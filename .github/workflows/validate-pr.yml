name: Validate Plugin Submission
on:
  pull_request:
    branches:
      - main
    paths:
      - 'plugins.json'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          path: main

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          path: pr

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate new plugin entry
        run: |
          node <<'EOL'
          const fs = require('fs');
          const https = require('https');

          async function main() {
            try {
              const mainPlugins = JSON.parse(fs.readFileSync('main/plugins.json', 'utf8'));
              const prPlugins = JSON.parse(fs.readFileSync('pr/plugins.json', 'utf8'));

              // Create sets for both repository URLs and plugin IDs for comprehensive comparison
              const mainRepoUrls = new Set(mainPlugins.map(p => p.repositoryUrl));
              const mainPluginIds = new Set(mainPlugins.map(p => p.id));
              
              // Find plugins that are completely new (not in main branch)
              const newPlugins = prPlugins.filter(p => 
                !mainRepoUrls.has(p.repositoryUrl) && !mainPluginIds.has(p.id)
              );

              // Find modified plugins (same ID or URL but different content)
              const modifiedPlugins = prPlugins.filter(p => {
                const mainPlugin = mainPlugins.find(mp => 
                  mp.repositoryUrl === p.repositoryUrl || mp.id === p.id
                );
                return mainPlugin && JSON.stringify(mainPlugin) !== JSON.stringify(p);
              });

              if (newPlugins.length === 0 && modifiedPlugins.length === 0) {
                console.log('No new or modified plugins detected in plugins.json.');
                process.exit(0);
              }

              // Check for conflicts: duplicate IDs or URLs within the PR
              const prRepoUrls = prPlugins.map(p => p.repositoryUrl);
              const prPluginIds = prPlugins.map(p => p.id);
              const duplicateUrls = prRepoUrls.filter((url, index) => prRepoUrls.indexOf(url) !== index);
              const duplicateIds = prPluginIds.filter((id, index) => prPluginIds.indexOf(id) !== index);

              if (duplicateUrls.length > 0) {
                throw new Error(`Duplicate repository URLs found in PR: ${duplicateUrls.join(', ')}`);
              }
              if (duplicateIds.length > 0) {
                throw new Error(`Duplicate plugin IDs found in PR: ${duplicateIds.join(', ')}`);
              }

              // Validate that only one new plugin is submitted per PR
              if (newPlugins.length > 1) {
                throw new Error('Error: Only one new plugin can be submitted per Pull Request.');
              }

              // Process new plugins
              for (const plugin of newPlugins) {
                console.log(`Validating new plugin: ${plugin.id} from ${plugin.repositoryUrl}`);
                const manifest = await fetchManifest(plugin.repositoryUrl);
                validateManifest(manifest, plugin);
              }

              // Process modified plugins
              for (const plugin of modifiedPlugins) {
                console.log(`Validating modified plugin: ${plugin.id} from ${plugin.repositoryUrl}`);
                const manifest = await fetchManifest(plugin.repositoryUrl);
                validateManifest(manifest, plugin);
              }

              const totalChanges = newPlugins.length + modifiedPlugins.length;
              console.log(`✅ Validation successful! Processed ${newPlugins.length} new and ${modifiedPlugins.length} modified plugins.`);
            } catch (error) {
              console.error(`❌ Validation failed: ${error.message}`);
              process.exit(1);
            }
          }

          function fetchManifest(repoUrl) {
            // Converts https://github.com/user/repo to https://raw.githubusercontent.com/user/repo/main/_manifest.json
            const rawUrl = repoUrl.replace('github.com', 'raw.githubusercontent.com') + '/main/_manifest.json';
            console.log(`Fetching manifest from: ${rawUrl}`);

            return new Promise((resolve, reject) => {
              https.get(rawUrl, res => {
                if (res.statusCode !== 200) {
                  return reject(new Error(`Could not fetch _manifest.json from repository. Status Code: ${res.statusCode}. Ensure the file exists in the 'main' branch.`));
                }
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(JSON.parse(data)));
              }).on('error', err => reject(new Error(`Network error fetching manifest: ${err.message}`)));
            });
          }

          function validateManifest(manifest, plugin) {
            const requiredFields = ['manifest_version', 'name', 'version', 'description', 'author', 'license', 'host_application'];
            for (const field of requiredFields) {
              if (!manifest[field]) throw new Error(`_manifest.json is missing required field: '${field}'`);
            }
            if (typeof manifest.author !== 'object' || !manifest.author.name || !manifest.author.url) {
                throw new Error("_manifest.json 'author' field must be an object with 'name' and 'url' properties.");
            }
            if (typeof manifest.host_application !== 'object' || !manifest.host_application.min_version) {
                throw new Error("_manifest.json 'host_application' field must be an object with a 'min_version' property.");
            }

            // Validate that plugin ID in plugins.json matches manifest name/id
            if (plugin && plugin.id !== manifest.name) {
              console.warn(`Warning: Plugin ID '${plugin.id}' in plugins.json differs from manifest name '${manifest.name}'. Consider keeping them consistent.`);
            }

            console.log(`Manifest structure is valid for plugin: ${manifest.name} v${manifest.version}`);
          }

          main();
          EOL